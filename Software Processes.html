<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title>Object-Oriented Programming and Data Abstraction  Lesson 1: Review</title>
  <meta name="generator" content="LibreOffice 25.8.4.2 (Linux)"/>
  <meta name="author" content="Jack Myers"/>
  <meta name="created" content="2013-12-20T15:33:26"/>
  <meta name="changedby" content="Jeffrey Pierantozzi"/>
  <meta name="changed" content="2020-09-09T12:47:47"/>
  <meta name="AppVersion" content="16.0000"/>
  <meta name="Notes" content="3"/>
  <meta name="PresentationFormat" content="On-screen Show (4:3)"/>
  <meta name="Slides" content="32"/>
</head>
<body>
<h1>Software Engineering I




	Chapter 2
	
	Software 	Processes</h1>
<h1 style="page-break-before:always; ">The software process</h1>
<ul>
<li>A structured set of activities required to develop a software system. </li>
<li>Many different software processes but all involve:</li>
<ul>
<li>Specification – defining what the system should do;</li>
<li>Design and implementation – defining the organization of the system and implementing the system;</li>
<li>Validation – checking that it does what the customer wants;</li>
<li>Evolution – changing the system in response to changing customer needs.</li>
</ul>
<li>A software process model is an abstract representation of a process. It presents a description of a process from some particular perspective.</li>
</ul>
<h1 style="page-break-before:always; ">Software process descriptions</h1>
<ul>
<li>When we describe and discuss processes, we usually talk about the activities in these processes such as specifying a data model, designing a user interface, etc. and the ordering of these activities.</li>
<li>Process descriptions may also include:</li>
<ul>
<li>Products, which are the outcomes of a process activity; </li>
<li>Roles, which reflect the responsibilities of the people involved in the process;</li>
<li>Pre- and post-conditions, which are statements that are true before and after a process activity has been enacted or a product produced.   </li>
</ul>
</ul>
<h1 style="page-break-before:always; ">Plan-driven and agile approaches</h1>
<ul>
<li>Plan-driven (predictive) approach consists of processes where all of the activities are planned in advance and progress is measured against this plan. </li>
<li>In agile approaches, planning is incremental and it is easier to change the process to reflect changing customer requirements. </li>
<li>In practice, most practical processes include elements of both plan-driven and agile approaches. </li>
<li>There are no right or wrong software processes.</li>
</ul>
<h1 style="page-break-before:always; ">System Development Life Cycle</h1>
<ul>
<li>No matter whether a project is plan-driven or agile, there are a series of activities that must be undertaken for every software engineering project</li>
<li>A systems development life cycle (SDLC) is composed of a number of clearly defined and distinct work phases which are used by systems engineers and systems developers to plan for, design, build, test, and deliver information systems. </li>
<li>There is no standard SDLC model, as each institution typically builds their own phases – however the tasks performed in each phase remain relatively constant from model to model</li>
</ul>
<h1 style="page-break-before:always; ">A representative SDLC</h1>
<p>Implementation</p>
<ul>
<li>This SDLC has 
seven phases</li>
<ul>
<li>Planning</li>
<li>Analysis</li>
<li>Design</li>
<li>Development</li>
<li>Integration and Testing</li>
<li>Implementation</li>
<li>Maintenance
</li>
<h2>Agile methodologies go 
through all these
phases multiple times</h2>
</ul>
</ul>
<p>Integration 
&amp; Testing</p>
<p>Maintenance</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p>Project
Mgmt</p>
<p>Project Management processes run 
in parallel to system development 
processes and will be discussed in a
later lecture.</p>
<h1 style="page-break-before:always; ">Planning</h1>
<ul>
<li>The <i>planning phase</i> of the SDLC involves determining 
a solid plan for developing your information system.</li>
<li>A <i>project manager</i>, an individual who is an expert in project 
planning and management may or may not be involved at this stage.</li>
<li>&nbsp;Three primary activities:</li>
<ul>
<li>Define the system to be developed.</li>
<ul>
<li>Identify and select the system for development or determine which 
system is required to support the strategic goals of your organization.</li>
<li><i>Critical success factors (CSF)</i> are factors critical to your organization’s success.</li>
</ul>
<li>Set the project scope.</li>
<ul>
<li>The <i>project scope</i> clearly defines the <i><b>high-level </b></i>system requirements and is the most basic definition of the system and is usually no longer than a paragraph.</li>
</ul>
<li>Define the <i><b>high level </b></i>project plan.</li>
<ul>
<li>At this stage of the project, the project plan may consist of nothing more than p<i>roject milestones</i> represent key dates by which you need a certain group of activities performed.</li>
<h2><i>A full blown project plan defines the what, when, and who questions of systems development activities including all activities, the individuals, or resources, who will perform the activities, and the time required to complete each activity </i></h2>
</ul>
</ul>
</ul>
<p>Planning</p>
<p><b>Begins with an idea</b></p>
<p><b></b></p>
<p><b>Ends with organizational approval</b></p>
<h1 style="page-break-before:always; ">Planning:
The Project Initiation Document (PID)</h1>
<ul>
<li><b>Project Scope Statement</b></li>
<ul>
<li>What is in scope and out of scope</li>
<li>Will project be delivered in phases?</li>
</ul>
<li><b>Project Background</b></li>
<ul>
<li>Why and how project was created.</li>
<li>History and context</li>
</ul>
<li><b>Feasibility Analysis</b></li>
<li><b>Assumptions, Dependencies and Constraints</b></li>
<li><b>Initial Project Plan</b></li>
<ul>
<li>High level milestones and dates</li>
<h2><b></b></h2>
<h2><i></i></h2>
</ul>
</ul>
<ul>
<li><b>Organization and Governance</b></li>
<ul>
<li>Team Organization Chart. </li>
<li>Governance structure and checkpoints</li>
</ul>
<li><b>Communication Plan</b></li>
<ul>
<li>e.g. weekly project team meetings, biweekly governance meetings, minutes…</li>
</ul>
<li><b>Quality Plan</b></li>
<ul>
<li>Often a list of deliverables</li>
</ul>
<li><b>Risk Assessment</b></li>
<ul>
<li>What are expected risks &amp; mitigation strategies</li>
</ul>
<li><b>Estimated Cost and ROI</b></li>
</ul>
<p>Planning</p>
<ul>
<ul>
<li>What the project is aiming and planning to achieve</li>
<li>The reason for the importance of meeting these aims. </li>
<li>Approved by Project Board (all stakeholders and mgmt)</li>
<li>Not regularly updated post-approval during project stages</li>
<li>May contain all or most of the sections below</li>
</ul>
</ul>
<h1 style="page-break-before:always; ">Analysis</h1>
<ul>
<li>The analysis phase of the SDLC involves end users 
and IT specialists working together to gather, 
understand, and document the business requirements 
for the proposed system.</li>
<li>The primary activity of this phase is to gather business 
requirements.  Business requirements are the detailed
set of knowledge worker requests that the system must 
meet to be successful.</li>
<li>Methodologies treat this phase differently</li>
<ul>
<li>Lock down requirements and only change if absolutely necessary</li>
<li>Define all requirements but allow/encourage revisions as 
project progresses</li>
<li>Allow requirements to be agilely added, removed and evolved 
over the course of the project</li>
</ul>
<li>Documentation standards vary with the methodology and the institution</li>
</ul>
<p>Planning</p>
<p>Analysis</p>
<p><b>Begins with organizational approval of
project

Ends?</b></p>
<h1 style="page-break-before:always; ">Software specification</h1>
<ul>
<li>The process of establishing what services are required and the constraints on the system’s operation and development.</li>
<li>Requirements engineering process</li>
<ul>
<li>Requirements elicitation and analysis</li>
<ul>
<li>What do the system stakeholders require or expect from the system?</li>
</ul>
<li>Requirements specification	</li>
<ul>
<li>Defining the requirements in detail</li>
</ul>
<li>Requirements validation</li>
<ul>
<li>Checking the validity of the requirements</li>
</ul>
</ul>
</ul>
<p>Analysis</p>
<h1 style="page-break-before:always; ">Design and Development</h1>
<ul>
<li>The primary goal of the <i>design phase</i> is to build a 
technical blueprint of how the proposed system will work.  Your point of view changes from a business perspective to a technical or physical perspective.</li>
<li>The <i>technical architecture</i> defines the hardware, 
software, and required networking configuration to 
run the system. </li>
<li>Defines and specifies the interfaces, parameters, 
and protocols used by product architecture and 
system architecture layers.</li>
<li>Design documentation could act as</li>
<ul>
<li>Specifications for development  OR</li>
<li>An outcome of development   <i>(or both!)</i></li>
</ul>
</ul>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p><b>Begins after requirements 
are established.  </b></p>
<ul>
<li><b>Technology should not constrain business needs</b></li>
<li><b>Technical capability should inspire the business, but not cause scope creep
</b></li>
<p><b>Ends?</b></p>
</ul>
<p>Design</p>
<p>Development</p>
<p>Development</p>
<p>Design</p>
<p>OR</p>
<p>Development</p>
<h1 style="page-break-before:always; ">A general model of the 
design process and activities </h1>
<ul>
<li><i>Architectural design,</i> where you identify the overall structure of the system, the principal components (subsystems or modules), their relationships and how they are distributed.</li>
<li><i>Database design, </i>where you design the system data structures and how these are to be represented in a database. </li>
<li><i>Interface design,</i> where you define the interfaces between system components. </li>
<li><i>Component selection and design, </i>where you search for 
reusable components. 
If unavailable, you design 
how it will operate. </li>
</ul>
<h1 style="page-break-before:always; ">Software development</h1>
<ul>
<li>The process of converting the system specification into an executable system.</li>
<li>Development</li>
<ul>
<li><i>Note:  Textbook sometimes uses the word &quot;implementation&quot; 
for the coding process – but this can be confused with the 
Implementation stage of the SDLC</i></li>
<li>Translate this structure into an executable program;</li>
</ul>
<li>The activities of design and development are 
closely related and may be inter-leaved.</li>
<li>The software is created either by developing a program or programs or by configuring an application system.</li>
<li>Programming is an individual activity with no standard process.</li>
<li>Debugging is the activity of finding program faults and correcting these faults.</li>
</ul>
<p>Design</p>
<p>Development</p>
<h1 style="page-break-before:always; ">Integration and Testing</h1>
<ul>
<li>The testing phase of the SDLC verifies that the system works and meets all the business requirements defined in the analysis phase.</li>
<li>First, you develop detailed test conditions, which 
are the detailed steps the system must perform
along with the expected results of each step.</li>
<li>Secondly, you actually perform the test.</li>
<li>Types of testing</li>
<ul>
<li>Ad hoc testing: normal testing performed by 
developer during coding process</li>
<li>Unit testing:  test only a single &quot;unit&quot; of the code
 (say a module or a class), to see if it behaves 
as expected in isolation</li>
<li>Integration testing: individual units are 
combined and tested as a group</li>
<li>System testing:  test the system as a whole.  </li>
</ul>
</ul>
<p>Integration 
&amp; Testing</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p><b>Begins once code and test plans are completed.
</b></p>
<p><b>Ends when all testing is finished
often with a User Acceptance
document</b></p>
<h1 style="page-break-before:always; ">Software validation</h1>
<ul>
<li>Verification and validation (V &amp; V) is intended to show that a system conforms to its specification and meets the requirements of the system customer.</li>
<li>Involves checking and review processes and system testing.</li>
<li>System testing involves executing the system with test cases that are derived from the specification of the real data to be processed by the system.</li>
<li>Testing is the most commonly used V &amp; V activity.</li>
</ul>
<p>Integration 
&amp; Testing</p>
<h1 style="page-break-before:always; ">Stages of testing</h1>
<p>Component or unit testing</p>
<p><i>Integration testing</i></p>
<p>System testing</p>
<p>Acceptance testing</p>
<p>Ad hoc testing</p>
<p><i>Optional for large systems</i></p>
<h1 style="page-break-before:always; ">Testing phases in a plan-driven software process (V-model)</h1>
<h1 style="page-break-before:always; ">Implementation</h1>
<p>Implementation</p>
<ul>
<li>During the implementation phase of the SDLC, you distribute the system to all the knowledge workers and they begin using the system to perform their everyday jobs </li>
<li>Typical activities</li>
<ul>
<li>Create Implementation Plan</li>
<li>Deploy system to a staging environment</li>
<li>Provide user documentation to the knowledge workers which explains how to use the system</li>
<li>Prepare the system support teams </li>
<li>Train knowledge workers</li>
</ul>
</ul>
<p>Integration 
&amp; Testing</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p><b>Begins at the conclusion of system testing
</b></p>
<p><b>Ends when system is put into production</b></p>
<h1 style="page-break-before:always; ">Implementation
Techniques</h1>
<p>Implementation</p>
<ul>
<li>Parallel implementation – using both the old and new system until you are sure that the new system performs correctly.</li>
<li>Plunge implementation – 
discarding the old system completely and using the new system</li>
<li>Pilot implementation – having only a small group of people use the new system until you know it works correctly, and then adding the remaining people to the system.</li>
<li>Phased implementation – implementing the new system one part at a time.</li>
</ul>
<p>Integration 
&amp; Testing</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<h1 style="page-break-before:always; ">Maintenance</h1>
<p>Implementation</p>
<ul>
<li>Monitor and support the new system to ensure it continues to meet the business goals</li>
<li>Change the system as your business changes </li>
<ul>
<li>Minor changes and bug fixes can be processed through change management processes which also go through their own SDLC</li>
<li>Major enhancements often require a new Project Initiation Document and, if approved, spawn their own SDLC</li>
</ul>
</ul>
<p>Integration 
&amp; Testing</p>
<p>Maintenance</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p><b>Begins when system is put into production
</b></p>
<p><b>Ends upon system 
decommissioning</b></p>
<h1 style="page-break-before:always; ">Software evolution</h1>
<ul>
<li>Software is inherently flexible and can change. </li>
<li>As requirements change through changing business circumstances, the software that supports the business must also evolve and change.</li>
<li>Although there has been a demarcation between development and evolution (maintenance) this is increasingly irrelevant as fewer and fewer systems are completely new.</li>
</ul>
<h1 style="page-break-before:always; ">System evolution </h1>
<h1 style="page-break-before:always; ">Software process models</h1>
<ul>
<li>The waterfall model</li>
<ul>
<li>Plan-driven model. Separate and distinct 
phases of specification and development.</li>
</ul>
<li>Incremental development</li>
<ul>
<li>Specification, development and validation 
are interleaved.  May be plan-driven or agile.</li>
</ul>
<li>Integration and configuration</li>
<ul>
<li>The system is assembled from existing configurable components. 
May be plan-driven or agile.</li>
</ul>
<li>In practice, most large systems are developed using a process that incorporates elements from all of these models.</li>
</ul>
<h1 style="page-break-before:always; ">1.  The waterfall model</h1>
<p>Implementation</p>
<p>Integration 
&amp; Testing</p>
<p>Maintenance</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p>Requirements
definition</p>
<p>System and Software Design</p>
<p>Implementation and Unit Testing</p>
<p>Integration and System Testing</p>
<p>Operation and  Maintenance</p>
<ul>
<li>In principle, the result of each phase is one or more documents that are signed off.</li>
<li>The following phase should not start until the previous phase has finished.
</li>
</ul>
<ul>
<li>In software development, these stages overlap and feed information to each other</li>
</ul>
<h1 style="page-break-before:always; ">Waterfall model problems</h1>
<ul>
<li>The main drawback of the waterfall model is the difficulty of accommodating change after the process is underway. In principle, a phase has to be complete before moving onto the next phase.</li>
<li>Inflexible partitioning of the project into distinct stages makes it difficult to respond to changing customer requirements.</li>
<ul>
<li>Therefore, this model is only appropriate when the requirements are well-understood and changes will be fairly limited during the design process. </li>
<li>Few business systems have stable requirements.</li>
</ul>
<li>The waterfall model is mostly used in two cases</li>
<ul>
<li>Highly regulated environments where deliverables are inspected as &quot;proof&quot; that processes were followed rigorously.</li>
<li>Large systems engineering projects where a system is developed at several sites.  In those circumstances, the plan-driven nature of the waterfall model helps coordinate the work. </li>
</ul>
</ul>
<h1 style="page-break-before:always; ">2.  Incremental development </h1>
<p>Based on the idea of developing an initial implementation, getting feedback from users and others evolving the software through several versions until the required system has been developed</p>
<p>Implementation</p>
<p>Integration 
&amp; Testing</p>
<p>Maintenance</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p>Agile/Scrum is a form of Incremental Development</p>
<p>Intermediate Versions</p>
<p>Validation</p>
<p>Development</p>
<p>Specification</p>
<p>Outline Description</p>
<p>Initial Version</p>
<p>Intermediate Versions</p>
<p>Final Version</p>
<h1 style="page-break-before:always; ">Incremental delivery </h1>
<h1 style="page-break-before:always; ">Incremental development 
compared to Waterfall</h1>
<h2>Benefits</h2>
<ul>
<li>Reduced cost to accommodate changing customer requirements</li>
<ul>
<li>The amount of analysis and documentation that has to be redone is much less than is required with the waterfall model.</li>
</ul>
<li>Easier to get customer feedback on the completed development work </li>
<ul>
<li>Customers can comment on demonstrations of the software and see how much has been implemented. </li>
</ul>
<li>More rapid delivery and deployment of useful software to the customer </li>
<ul>
<li>Customers are able to use and gain value from the software earlier than is possible with a waterfall process. </li>
</ul>
</ul>
<h2>Downsides</h2>
<ul>
<li>The process is not visible. </li>
<ul>
<li>Managers often want regular deliverables to measure progress. </li>
<li>If systems are developed quickly, it is not cost-effective to produce documents that reflect every version of the system. </li>
</ul>
<li>System structure may degrade as new increments are added<i>. </i> </li>
<ul>
<li>Unless time and money is spent on refactoring to improve the software, regular change tends to corrupt its structure. </li>
<li>Incorporating further software changes becomes increasingly difficult and costly. </li>
</ul>
</ul>
<h1 style="page-break-before:always; ">Incremental delivery 
advantages and problems</h1>
<h2>Advantages</h2>
<ul>
<li>Customer value can be delivered with each increment so system functionality is available earlier.</li>
<li>Early increments act as a prototype to help elicit requirements for later increments.</li>
<li>Lower risk of overall project failure.</li>
<li>The highest priority system services tend to receive the most testing.</li>
</ul>
<h2>Problems</h2>
<ul>
<li>Most systems require a set of basic facilities that are used by different parts of the system. </li>
<ul>
<li>As requirements are not defined in detail until an increment is to be implemented, it can be hard to identify common facilities that are needed by all increments. </li>
</ul>
<li>The essence of iterative processes is that the specification is developed in conjunction with the software. </li>
<ul>
<li>However, this conflicts with the procurement model of many organizations, where the complete system specification is part of the system development contract. </li>
</ul>
</ul>
<h1 style="page-break-before:always; ">3. Integration and configuration
based on reuse</h1>
<h2>Reusability
</h2>
<ul>
<li>Based on software reuse where systems are integrated from existing components or application systems (sometimes called COTS -Commercial-off-the-shelf) systems).
</li>
<li>Reused elements may be configured to adapt their behaviour and functionality to a user’s requirements
</li>
<li>Reuse is now the standard approach for building many types of business system</li>
</ul>
<h2>Types of Reusable Software
 </h2>
<ul>
<li>Stand-alone application systems (sometimes called COTS) that are configured for use in a particular environment.
</li>
<li>Collections of objects that are developed as a package to be integrated with a component framework such as .NET or J2EE.
</li>
<li>Web services that are developed according to service standards and which are available for remote invocation. </li>
</ul>
<h1 style="page-break-before:always; ">3. Integration and configuration
development</h1>
<p>Implementation</p>
<p>Integration 
&amp; Testing</p>
<p>Maintenance</p>
<p>Planning</p>
<p>Analysis</p>
<p>Design</p>
<p>Development</p>
<p>Adapt components</p>
<p>Develop new components</p>
<p>Configure application system</p>
<p>Integrate System</p>
<p>Requirements refinement</p>
<p>Requirements specification</p>
<ul>
<li>Requirements specification:  initial requirements for system; description of essential requirements and desirable features</li>
<li>Software discovery and evaluation: search for components,
plug-ins and configuration options to meet requirements</li>
<li>Requirements refinement:  requirements may change 
based on system capability</li>
<li>Application system configuration: configure the off-the-shelf system</li>
<li>Component adaptation and integration: customize components using application's API.</li>
</ul>
<h1 style="page-break-before:always; ">Advantages and disadvantages of Integration and configuration development</h1>
<ul>
<li>Reduced costs and risks as less software is developed from scratch</li>
<li>Faster delivery and deployment of system</li>
<li>But requirements compromises are inevitable so system may not meet real needs of users</li>
<li>Loss of control over evolution of reused system elements</li>
</ul>
</body>
</html>